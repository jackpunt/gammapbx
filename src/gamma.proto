syntax = "proto3";
//package display.client;

// add_unit(id,type,owner,loc[x,y],hp) : create unit of 'type' at 'loc' and register as 'id'
// del_unit(id) : he's dead, jim
// update(id, [owner], [loc], [hp], ...)

message Iloc {
    int32	y = 1;
    int32	x = 2;
}
message Floc {
    float	y = 1;
    float	x = 2;
}

// delta loc .. is this robust/usable? 
// Expect to send keyframe every 5 or so
// interpolated with FDloc/IDloc updates
// [or not: if keyframe includes a Dloc, and unit still on track]
message IDloc {
    int32	dy = 1;
    int32	dx = 2;
}
// delta loc
message FDloc {
    float	dy = 1;
    float	dx = 2;
}
// set a speed: [dloc/dturn]
message Dloc {
    float	dy_dt = 1;
    float	dx_dt = 2;
}

message Turn {
    uint32	id = 1;		// new turn number; no Seq for this...
}

// type of following message:
message AMessage {
    Turn        turn = 1;	// Turn
    UpdateSeq   updates = 2;	// Update
    RevealSeq   reveals = 3;	// Reveal
    AddSeq      adds = 4;	// Add (Ident, Update)
    DelSeq      dels = 5;	// Del
    TerImageSeq ter_images = 21;// TerImage, ImageAry
    ModImageSeq mod_images = 22;// ModImage, ImageAry
    ZHeightMap  z_height_map = 25;
}
enum Fields {
    none = 0;
    turn = 1;
    update=2;
    reveal=3;
    add  = 4;
    del  = 5;
    tmap = 21;
    zmap = 22;
    imag = 23;
}

// add Player? add Unit?
// ADD[{id=1, type="Player", display="Self", ...}
//     {id=2, type="Player", display="Other", ...}
//     {id=3, type="Player", display="Gaia", ...}
//     {id=4, type="HQ", player=1, loc=[x0,y0], display="HQ"}	 at site of primary lander
//     {id=5, type="Scout", player=1, loc=[x1,y1], display="Scout-0"}
//    ]
// Code:REVEAL
// TerMap[{loc=[x0,y0], type="GRASS", level=34}]


// Unit position/health update:
// Update-Floc, Update-Iloc, Update-Dloc, ...
message Update {
    uint32	id = 1;		// objectId (required)
    int32	hp = 2;		// hp for Unit update
    bool	isHp = 3;
    // one of {floc, iloc}
    Floc	floc = 4;
    bool	is_floc = 5;
    Iloc	iloc = 6;
    bool	is_iloc = 7;
    // set expected speed: (close enough for many purposes; on keyframe set Floc/Idoc)
    Dloc	dloc = 8;
    bool	is_dloc = 9;
    // change of owner: push it into Ident[id]
    uint32	player_id = 10;
}

message UpdateSeq {
    repeated Update updates = 1;
}

// unit identity and presentation
message Ident {
    uint32	id = 1;		// unit_id, referenced in Update, Del (from Update, if missing)
    string	type = 2;	// engineer, building, scout, etc (determines menu)
    uint32	i_ndx = 3;	// ModImage of constant size icon
    uint32	m_ndx = 4;	// 2D ModImage (scaled image or shape) or 3D-model identifier
    string	display = 8;	// display name for new Unit (hovertext: eng#5)
    uint32	player_id = 10;	// new Unit associated with Player (player id, livery)
}

// add Unit (or Player/Team/Civ)
// Add { type, player, display, Update }
message Add {
    Ident	ident = 1;	// who/what
    Update	update = 2;	// where (initial value)
}
message AddSeq {
    repeated Add adds = 1;
}

message Del {
    uint32	id = 2;		// required
}
message DelSeq {
    repeated Del dels = 1;
}

// from iloc(x,y) do set (x..+dx,y) to (tid,z)
message TerRunX {
    int32	dx = 2;		// small positive number, relative to loc [default=1]
    uint32	tid = 3;	// index into terrain type map
    uint32	zndx = 4;	// index into z-height map: z-height=zmap[zndx]
    int32	zval = 5;	// actual z-height value
}
message TerRasterY { 		// extends Iloc?
    Iloc	loc = 1;	// start at (y,x) [upper-left corner]
    repeated TerRunX rowx = 2;	// for i=0...: (y+i: (x+dx0, tid0, z0), (x+dx1, tid1, z1))
}
message RevealSeq {
    repeated TerRasterY rastery = 1;
}

// usage: extract a single pixel at img[r,c] given a {x,y,tid}
// tid maps to a npx X npx subimage
// img[r,c] -> tid(r*ncols+c); tid->(tid/ncols,tid%ncols)
message ImageAry {
    uint32 npixels = 1;	// each sub-image is npixels X npixels, in  row major order
    uint32 nrows = 2;	// each of the nrows
    uint32 ncols = 3;	// has ncols
    string url = 4;	// fetch master image
}

// override implict image location (from parsing ndx relative to ImageAry)
message SubImage {
    uint32	y0 = 2;		// npixels*(r=tid/ncols)
    uint32	x0 = 3;		// npixels*(c=tid%ncols)
    uint32	y_px = 4;	// npixels
    uint32	x_px = 5;	// npixels
    uint32	y_off = 6;	// 0 (offset to drag/rotate center)
    uint32	x_off = 7;	// 0 (offset to drag/rotate center)
    string	alt_url = 8;	// use alternative image (RARE)
}

// ImageAry implicitly associate tids in range [0..nr*nc]
// with the sub-images in ImageAry at: img[r=tid/ncols, c=tid%ncols] [npixels X npixels]
// Tmap associates each tid with a display name
message TerImage {
    uint32	tid = 1;
    string	name = 2;	// advisory, for alt presentation, description
    SubImage	sub_image = 3;
}

// images for unit models, or other non-terrain things (on the unit-canvas)
// set mapping from m_ndx and icon_ndx to image (in ImageAry mblk)
// for each player, create a master with the livery color replaced
message ModImage {
    uint32	ndx = 1;
    string	name = 2;	// model/image display name (dubious)
    SubImage	sub_image = 3;
    uint32	p_color = 5;	// replace pixels of this RGB with player's color [livery]
    // or maybe it is constant: #888888, #F10102 ?
}

message TerImageSeq {
    ImageAry	tblk = 1;
    repeated TerImage tmaps = 2;
}

message ModImageSeq {
    ImageAry	mblk = 1;	// master image
    repeated ModImage models = 2;// extract sub-image(a 2D model), call it models[ndx] 
}

// not sure we need this..
// compress 300m 500m ... 4000m ... 6000m to small ints
// (but it quantizes the z-heights)
// stuff these heights into a map for future reference: zheight[zndx+I(repeat)]=zval
message ZHeightMap {
    uint32 zndx = 2;
    repeated int32 zval = 3;
}
